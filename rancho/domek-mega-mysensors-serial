/**
* The MySensors Arduino library handles the wireless radio link and protocol
* between your home built sensors/actuators and HA controller of choice.
* The sensors forms a self healing radio network with optional repeaters. Each
* repeater and gateway builds a routing tables in EEPROM which keeps track of the
* network topology allowing messages to be routed to nodes.
*
* Created by Henrik Ekblad <henrik.ekblad@mysensors.org>
* Copyright (C) 2013-2019 Sensnology AB
* Full contributor list: https://github.com/mysensors/MySensors/graphs/contributors
*
* Documentation: http://www.mysensors.org
* Support Forum: http://forum.mysensors.org
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* version 2 as published by the Free Software Foundation.
*
*******************************
*
* DESCRIPTION
* The ArduinoGateway prints data received from sensors on the serial link.
* The gateway accepts input on serial which will be sent out on radio network.
*
* The GW code is designed for Arduino Nano 328p / 16MHz
*
* Wire connections (OPTIONAL):
* - Inclusion button should be connected between digital pin 3 and GND
* - RX/TX/ERR leds need to be connected between +5V (anode) and digital pin 6/5/4 with resistor 270-330R in a series
*
* LEDs (OPTIONAL):
* - To use the feature, uncomment any of the MY_DEFAULT_xx_LED_PINs
* - RX (green) - blink fast on radio message received. In inclusion mode will blink fast only on presentation received
* - TX (yellow) - blink fast on radio message transmitted. In inclusion mode will blink slowly
* - ERR (red) - fast blink on error during transmission error or receive crc error
*
*/

// Enable debug prints to serial monitor
#define MY_DEBUG


// Enable and select radio type attached
// #define MY_RADIO_RF24
//#define MY_RADIO_NRF5_ESB
//#define MY_RADIO_RFM69
//#define MY_RADIO_RFM95

// Set LOW transmit power level as default, if you have an amplified NRF-module and
// power your radio separately with a good regulator you can turn up PA level.
// #define MY_RF24_PA_LEVEL RF24_PA_LOW

// Enable serial gateway
#define MY_GATEWAY_SERIAL

// Define a lower baud rate for Arduinos running on 8 MHz (Arduino Pro Mini 3.3V & SenseBender)
#if F_CPU == 8000000L
#define MY_BAUD_RATE 38400
#endif

// Enable inclusion mode
#define MY_INCLUSION_MODE_FEATURE
// Enable Inclusion mode button on gateway
//#define MY_INCLUSION_BUTTON_FEATURE

// Inverses behavior of inclusion button (if using external pullup)
//#define MY_INCLUSION_BUTTON_EXTERNAL_PULLUP

// Set inclusion mode duration (in seconds)
#define MY_INCLUSION_MODE_DURATION 60
// Digital pin used for inclusion mode button
//#define MY_INCLUSION_MODE_BUTTON_PIN  3

// Set blinking period
#define MY_DEFAULT_LED_BLINK_PERIOD 300

// Inverses the behavior of leds
//#define MY_WITH_LEDS_BLINKING_INVERSE

// Flash leds on rx/tx/err
// Uncomment to override default HW configurations
//#define MY_DEFAULT_ERR_LED_PIN 4  // Error led pin
//#define MY_DEFAULT_RX_LED_PIN  6  // Receive led pin
//#define MY_DEFAULT_TX_LED_PIN  5  // the PCB, on board LED

#include <MySensors.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>
#include <dht.h>

unsigned long currentMillis;
bool initialValueSent = false;
const long SENSORS_READ_FREQUENCY = 60000;
long lastSensorsReadMillis = -100000000;

const long SECURITY_SENSORS_READ_FREQUENCY = 3000;
long lastSecuritySensorsReadMillis = -100000000;

const long MOTION_SENSORS_READ_FREQUENCY = 1000;
long lastMotionSensorsReadMillis = -100000000;

//------------- light sensors -----------------//
/*
5V - sensor1
sensor2 - 10kO - analogRead
10kO - GND
*/

//IDs starting with 0
#define H1_ID 0
#define H1_PIN A0
MyMessage msgH1(H1_ID, V_LIGHT_LEVEL);

// Enable repeater functionality for this node
#define MY_REPEATER_FEATURE

//------------- relays -----------------//
#define RELAY_ON 0  // GPIO value to write to turn on attached relay
#define RELAY_OFF 1 // GPIO value to write to turn off attached relay
#define RELAY_5V_PIN 22

//IDs starting with 20
#define M6_ID 20
#define M6_PIN 32
MyMessage msgM6(M6_ID, V_STATUS);


//------------- roller shutters -----------------//
//IDs starting with 10

long lastRollerShutterActionStart;
const long MAX_ROLLER_SHUTTER_OPERATION_DURATION = 20000;
boolean rollerShuttersInOperation = false;

#define M10_ID 10
#define M10_DOWN_PIN 24
#define M10_UP_PIN 25
MyMessage msgM10(M10_ID, V_STATUS);

#define M11_ID 11
#define M11_DOWN_PIN 26
#define M11_UP_PIN 27
MyMessage msgM11(M11_ID, V_STATUS);

#define M12_ID 12
#define M12_DOWN_PIN 28
#define M12_UP_PIN 29
MyMessage msgM12(M12_ID, V_STATUS);

#define M13_ID 13
#define M13_DOWN_PIN 30
#define M13_UP_PIN 31
MyMessage msgM13(M13_ID, V_STATUS);


//------------- temperature sensors -----------------//
//IDs starting with 30

//NTC floor temperature sensors
/*
5V - sensor1
sensor2 - 10kO - analogRead
10kO - GND
*/
#define NTC_NOMINAL_RESISTANCE 10000       //Nominal resistance at 25⁰C
#define NTC_NOMINAL_TEMPERATURE 25   // temperature for nominal resistance (almost always 25⁰ C)
#define ntc_samplingrate 10
#define NTC_BETA 3950  // The beta coefficient or the B value of the thermistor (usually 3000-4000) check the datasheet for the accurate value.
#define NTC_REF_RESISTOR 10000   //Value of  resistor used for the voltage divider

#define D1_ID 30
#define D1_PIN A1
MyMessage msgD1(D1_ID, V_TEMP);
#define FLOOR_HEATER_SAFE_TEMPERATURE_LIMIT 30.0
#define FLOOR_TEMPERATURE_SENSOR_MIN_VALUE 0.0
#define FLOOR_TEMPERATURE_SENSOR_MAX_VALUE 50.0


//BME280 sensor setup
/*
SCK -> SCL (21)
SDA -> SDA (20)
*/
#define ALTITUDE 0

#define D9_ID 31
Adafruit_BME280 D9_bme; // I2C
MyMessage msgD9(D9_ID, V_TEMP);
boolean d9Status;

//DHT22 sensor setup
/*
1- > 5V
2 -> 5V + 10kO - DATA
3 -> 
4 -> GND
*/
dht D4_DHT22;
#define D4_ID 32
#define D4_PIN A3
MyMessage msgD4(D4_ID, V_TEMP);
int d4Status;

dht D2_DHT22;
#define D2_ID 33
#define D2_PIN A4
MyMessage msgD2(D2_ID, V_TEMP);
int d2Status;



//------------- pressure sensors -----------------//
//IDs starting with 40
#define N7_ID 40
MyMessage msgN7(N7_ID, V_PRESSURE);



//------------- humidity sensors -----------------//
//IDs starting with 50
#define C7_ID 50
MyMessage msgC7(C7_ID, V_HUM);

#define C2_ID 51
MyMessage msgC2(C2_ID, V_HUM);

#define C1_ID 52
MyMessage msgC1(C1_ID, V_HUM);



//------------- contact sensors -----------------//
//IDs starting with 60
//sensor setup
/*
1- > GND
2 -> DATA
*/
#define G2_ID 60
#define G2_PIN 40
MyMessage msgG2(G2_ID, V_TRIPPED);
int g2State = -1;



//------------- water leak sensors -----------------//
//IDs starting with 80
//sensor setup
/*
1- > 5V
2 -> GND
4 -> ANALOG DATA
*/
#define E2_ID 80
#define E2_PIN A5
MyMessage msgE2(E2_ID, V_TRIPPED);
int e2State = -1;
int waterLeakThresholdValue = 500;


//------------- noise sensors -----------------//
//IDs starting with 90
//sensor setup
// !!!! make sure to calibrate the sensor !!!!
/*
2 -> GND
3 -> 5V
4 -> DATA
*/
#define F2_ID 90
#define F2_PIN 41
MyMessage msgF2(F2_ID, V_TRIPPED);
int f2State = -1;


//------------- motion sensors -----------------//
//IDs starting with 100
//sensor setup
// !!!! make sure to calibrate the sensor !!!!
#define I1_ID 100
#define I1_PIN 42
MyMessage msgI1(I1_ID, V_TRIPPED);
int i1State = -1;





void presentation() {
  	// Send the sketch version information to the gateway and Controller
	sendSketchInfo("Domek MEGA Serial", "1.0");

	// Register all sensors to gateway (they will be created as child devices)
	present(H1_ID, S_LIGHT_LEVEL, "H1");

  present(M10_ID, S_BINARY, "M10");
  present(M11_ID, S_BINARY, "M11");
  present(M12_ID, S_BINARY, "M12");
  present(M13_ID, S_BINARY, "M13");

  present(M6_ID, S_BINARY, "M6");

  present(D1_ID, S_TEMP, "D1");
  present(D9_ID, S_TEMP, "D9");
  present(D4_ID, S_TEMP, "D4");
  present(D2_ID, S_TEMP, "D2");

  present(N7_ID, S_BARO, "N7");

  present(C7_ID, S_HUM, "C7");
  present(C2_ID, S_HUM, "C2");
  present(C1_ID, S_HUM, "C1");

  present(G2_ID, S_DOOR, "G2");

  present(E2_ID, S_WATER_LEAK, "E2");
  
  present(F2_ID, S_SOUND, "F2");

  present(I1_ID, S_MOTION, "I1");
}

void before() {
  initializeRelays();
  pinMode(H1_PIN, INPUT);
  pinMode(D1_PIN, INPUT);
  initializeBme280Sensors();
  initializeContactSensors();
  initializeWaterLeakSensors();
  pinMode(F2_PIN, INPUT);
  pinMode(I1_PIN, INPUT);
}

void initializeRelays() {
  //first set the relays off to avoid roller shutters damage
  pinMode(RELAY_5V_PIN, OUTPUT);
  digitalWrite(RELAY_5V_PIN, LOW);

	pinMode(M10_DOWN_PIN, OUTPUT);
	pinMode(M10_UP_PIN, OUTPUT);
	pinMode(M11_DOWN_PIN, OUTPUT);
	pinMode(M11_UP_PIN, OUTPUT);
	pinMode(M12_DOWN_PIN, OUTPUT);
	pinMode(M12_UP_PIN, OUTPUT);
	pinMode(M13_DOWN_PIN, OUTPUT);
	pinMode(M13_UP_PIN, OUTPUT);
  switchOffAllRollerShutters();

  digitalWrite(M6_PIN, RELAY_OFF);
	pinMode(M6_PIN, OUTPUT);

  delay(10);
  digitalWrite(RELAY_5V_PIN, HIGH);
}

void switchOffAllRollerShutters() {
  rollerShuttersInOperation = false;
  digitalWrite(M10_DOWN_PIN, RELAY_OFF);
  digitalWrite(M10_UP_PIN, RELAY_OFF);
  digitalWrite(M11_DOWN_PIN, RELAY_OFF);
  digitalWrite(M11_UP_PIN, RELAY_OFF);
  digitalWrite(M12_DOWN_PIN, RELAY_OFF);
  digitalWrite(M12_UP_PIN, RELAY_OFF);
  digitalWrite(M13_DOWN_PIN, RELAY_OFF);
  digitalWrite(M13_UP_PIN, RELAY_OFF);
}

void initializeBme280Sensors() {
  d9Status = D9_bme.begin(0x76);  //The I2C address of the sensor I use is 0x76
  if (!d9Status) {
      handleInvalidD9Status();
  }
}

void handleInvalidD9Status() {
  Serial.print("D9 Sensor not working, check connections");
  send(msgD9.set("N/A"));
  send(msgC7.set("N/A"));
  send(msgN7.set("N/A"));
}

void initializeContactSensors() {
  pinMode(G2_PIN, INPUT);
  digitalWrite(G2_PIN, HIGH);  
}

void initializeWaterLeakSensors() {
  pinMode(E2_PIN, INPUT);
}



void loop() {
  currentMillis = millis();
  if (!initialValueSent) {
    setInitialValuesFromController();
    initialValueSent = true;
  }
  if (rollerShuttersInOperation && currentMillis - lastRollerShutterActionStart > MAX_ROLLER_SHUTTER_OPERATION_DURATION) {
    switchOffAllRollerShutters();
  }
  if (currentMillis - lastSensorsReadMillis > SENSORS_READ_FREQUENCY) {
    lastSensorsReadMillis = currentMillis;
    readLightSensors();
    readTemperatureSensors();
    readPressureSensors();
    readHumiditySensors();
    readWaterLeakSensors();
  }
  if (currentMillis - lastSecuritySensorsReadMillis > SECURITY_SENSORS_READ_FREQUENCY) {
    lastSecuritySensorsReadMillis = currentMillis;
    readContactSensors();
    readNoiseSensors();
  }

   if (currentMillis - lastMotionSensorsReadMillis > MOTION_SENSORS_READ_FREQUENCY) {
    lastMotionSensorsReadMillis = currentMillis;
    readMotionSensors();
  }

}

void receive(const MyMessage &message) {
  Serial.println("Message received. Type: " + String(message.getType()) + ", device: " + String(message.getSensor()) + ", command: " + String(message.getCommand()) 
                + ", bool: " + String(message.getBool()));
	if (message.isAck()) {
     Serial.println("This is an ack from gateway");
  }
  if (message.type == V_STATUS) {
    Serial.println("Change relay state");
    if(message.getSensor() == M10_ID) {
      moveRollerShutter(message.getBool(), M10_DOWN_PIN, M10_UP_PIN, msgM10, "M10");
    } else if(message.getSensor() == M11_ID) {
      moveRollerShutter(message.getBool(), M11_DOWN_PIN, M11_UP_PIN, msgM11, "M11");
    } else if(message.getSensor() == M12_ID) {
      moveRollerShutter(message.getBool(), M12_DOWN_PIN, M12_UP_PIN, msgM12, "M12");
    } else if(message.getSensor() == M13_ID) {
      moveRollerShutter(message.getBool(), M13_DOWN_PIN, M13_UP_PIN, msgM13, "M13");
    } else if(message.getSensor() == M6_ID) {
      setRelayValue(message.getBool(), M6_PIN, msgM6, "M6");
    } else {
      Serial.println("Unknown device: " + message.getSensor());
    }
  }
}

void moveRollerShutter(boolean state, int pinDown, int pinUp, MyMessage msg, String device) {
  Serial.println("Moving " + device + " shutter " + state?"UP":"DOWN");
  lastRollerShutterActionStart = currentMillis;
  rollerShuttersInOperation = true;
  if (state) {
    digitalWrite(pinDown, RELAY_OFF);
    delay(10);
    digitalWrite(pinUp, RELAY_ON);
    send(msg.set(1));
  } else {
    digitalWrite(pinUp, RELAY_OFF);
    delay(10);
    digitalWrite(pinDown, RELAY_ON);
    send(msg.set(0));
  } 
}

void setRelayValue(boolean state, int pin, MyMessage msg, String device) {
  Serial.println("Setting " + device + " relay " + state?"ON":"OFF");
  if (state) {
    digitalWrite(pin, RELAY_ON);
    send(msg.set(1));
  } else {
    digitalWrite(pin, RELAY_OFF);
    send(msg.set(0));
  } 
}

void setInitialValuesFromController() {
  Serial.println("Setting initial values from controller");
  setInitialRelayValue(M10_ID, msgM10);
  setInitialRelayValue(M11_ID, msgM11);
  setInitialRelayValue(M12_ID, msgM12);
  setInitialRelayValue(M13_ID, msgM13);

  setInitialRelayValue(M6_ID, msgM6);
 
  wait(2000, C_SET, V_STATUS);
}

void setInitialRelayValue(int ID, MyMessage msg) {
  boolean state = request(ID, V_STATUS);
  if (state) {
    send(msg.set(1));
  } else {
    send(msg.set(0));
  }
}

void readLightSensors() {
  Serial.println("Reading light sensors values");
  sendValidSensorValue(String(analogRead(H1_PIN)/10.23), msgH1, "H1");
}

void readTemperatureSensors() {
  Serial.println("Reading temperature sensors values");
  readFloorTemperatureSensors();
  readBme280TemperatureSensors();
  readDHT22TemperatureSensors();
}

void readBme280TemperatureSensors() {
  if (!d9Status) {
    initializeBme280Sensors();
  } else {
    sendValidSensorValue(String(D9_bme.readTemperature(), 1), msgD9, "D9");
  }
}

void readDHT22TemperatureSensors() {
  d4Status = D4_DHT22.read22(D4_PIN);
  if (d4Status != 0) {
    handleInvalidD4DhtStatus();
  } else {
    sendValidSensorValue(String(D4_DHT22.temperature, 1), msgD4, "D4");
  }
  d2Status = D2_DHT22.read22(D2_PIN);
  if (d2Status != 0) {
    handleInvalidD2DhtStatus();
  } else {
    sendValidSensorValue(String(D2_DHT22.temperature, 1), msgD2, "D2");
  }
}

void sendValidSensorValue(String value, MyMessage msg, String device) {
  Serial.println("Sending " + device + " sensor value: " + value);
  send(msg.set(value));
}

void handleInvalidD4DhtStatus() {
  String status = getDhtErrorStatus(d4Status);
  Serial.print("D4 sensor status: " + status);
  send(msgD4.set(status));
  send(msgC2.set(status));
}

void handleInvalidD2DhtStatus() {
  String status = getDhtErrorStatus(d2Status);
  Serial.print("D2 sensor status: " + status);
  send(msgD2.set(status));
  send(msgC1.set(status));
}

String getDhtErrorStatus(int statusCode) {
  String status;
  switch (d4Status) {
     case DHTLIB_ERROR_CHECKSUM:
      status = "DHTLIB_ERROR_CHECKSUM";
      break;
    case DHTLIB_ERROR_TIMEOUT:
      status = "DHTLIB_ERROR_TIMEOUT";
      break;
    default:
      status = "UNKNOWN_ERROR";
      break;
  }
  return status;
}


void readFloorTemperatureSensors() {
  uint8_t i;
  float d1Average = 0;
  int d1Reads = 0;
  for (i = 0; i < ntc_samplingrate; i++) {
    int value = analogRead(D1_PIN);
    Serial.print("D1 value read number ");
    Serial.print(i);
    Serial.print(": ");
    Serial.println(value);
    d1Reads += value;
    delay(20);
  }
  d1Average = d1Reads / ntc_samplingrate;
  d1Average = 1023 / d1Average - 1;
  d1Average = NTC_REF_RESISTOR / d1Average;
  Serial.print("D1 Thermistor resistance ");
  Serial.println(d1Average);
  float d1Temperature;
  d1Temperature = d1Average / NTC_NOMINAL_RESISTANCE;     // (R/Ro)
  d1Temperature = log(d1Temperature);                  // ln(R/Ro)
  d1Temperature /= NTC_BETA;                   // 1/B * ln(R/Ro)
  d1Temperature += 1.0 / (NTC_NOMINAL_TEMPERATURE + 273.15); // + (1/To)
  d1Temperature = 1.0 / d1Temperature;                 // Invert
  d1Temperature -= 273.15;                         // convert absolute temp to C
  Serial.print("D1 Temperature ");
  Serial.print(d1Temperature);
  Serial.println(" °C");
  if (d1Temperature < FLOOR_TEMPERATURE_SENSOR_MIN_VALUE || d1Temperature > FLOOR_TEMPERATURE_SENSOR_MAX_VALUE) {
    send(msgD1.set("N/A"));
  } else {
    send(msgD1.set(d1Temperature,1));
  }
  safetyCheckForFloorHeater(d1Temperature);
}

void safetyCheckForFloorHeater(float temperature) {
  if (temperature > FLOOR_HEATER_SAFE_TEMPERATURE_LIMIT) {
    setRelayValue(false, M6_PIN, msgM6, "M6");
  } 
}

void readPressureSensors() {
  Serial.println("Reading pressure sensors values");
  readBme280PressureSensors();
}

void readBme280PressureSensors() {
  if (!d9Status) {
    return;
  }
  float n7Pressure = D9_bme.readPressure();
  n7Pressure = D9_bme.seaLevelForAltitude(ALTITUDE, n7Pressure);
  n7Pressure = n7Pressure/100.0F;
  sendValidSensorValue(String(n7Pressure,2), msgN7, "N7");
}

void readHumiditySensors() {
  Serial.println("Reading humidity sensors values");
  readBme280HumiditySensors();
  readDHT22HumiditySensors();
}

void readBme280HumiditySensors() {
  if (!d9Status) {
    return;
  }
  sendValidSensorValue(String(D9_bme.readHumidity(), 0), msgC7, "C7");
}

void readDHT22HumiditySensors() {
  if (d4Status == 0) {
    sendValidSensorValue(String(D4_DHT22.humidity, 1), msgC2, "C2");
  }
  if (d2Status == 0) {
    sendValidSensorValue(String(D2_DHT22.humidity, 1), msgC1, "C1");
  }
}

void readContactSensors() {
  Serial.println("Reading contact sensors");
  int g2CurrentState = digitalRead(G2_PIN);
  if (g2CurrentState != g2State) {
    sendValidSensorValue((g2CurrentState==HIGH ? "1" : "0"), msgG2, "G2");
    g2State = g2CurrentState;
  }
}

void readNoiseSensors() {
  Serial.println("Reading noise sensors");
  int f2NoisySounds = 0;
  for (int i=1; i<5; i++) {
    if (digitalRead(F2_PIN)) f2NoisySounds++;
    delay(10);
  }
  boolean f2CurrentState = f2NoisySounds > 3;
  if (f2CurrentState != f2State) {
    sendValidSensorValue((f2CurrentState==HIGH ? "1" : "0"), msgF2, "F2");
    f2State = f2CurrentState;
  }
}

void readWaterLeakSensors() {
  Serial.println("Reading water leak sensors");
  int e2CurrentState = analogRead(E2_PIN);
  if (e2CurrentState != e2State) {
    sendValidSensorValue((e2CurrentState==HIGH ? "1" : "0"), msgE2, "E2");
    e2State = e2CurrentState;
  }
}

void readMotionSensors() {
  Serial.println("Reading motion sensors");
  int i1CurrentState = digitalRead(I1_PIN);
  if (i1CurrentState != i1State) {
    sendValidSensorValue((i1CurrentState==HIGH ? "1" : "0"), msgI1, "I1");
    i1State = i1CurrentState;
  }
}


